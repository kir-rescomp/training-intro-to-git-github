# <h1 align="center">4. Git Concepts, Data Model and Commands üé®</h1>

<p align="center">
    <img src="../images/gitcommand_episode_logo.png" alt="drawing" width="250">
</p>



<h2 align="center">Version Control for Cell Clusters ‚Äî A Git Journey in the Lab</h2>

Dr. X is a computational biologist working on a new single-cell RNA sequencing (scRNA-seq) pipeline.
Like most data scientists, their workflow involves constant tweaking: preprocessing, quality control, normalization, clustering, and visualization.

They are tired of lost scripts, mysterious file versions like `clustering_final_FINAL.R`, and overwritten notebooks.

So, they decided to version-control their pipeline properly using **Git**

### 1. `git init` - Starting a new experiment 

They begin their project as they would a new experiment ‚Äî setting up a clean workspace.

!!! terminal ""

    ```bash
    mkdir CellCulsterFlow
    cd CellClusterFlow
    ```
    
    ```bash
    git init
    ```
This initialises an empty Git repository, like labeling an empty freezer box before adding samples.
Every change from here on will be tracked.

They create few essential files 

```bash
README.md
LICENSE
data_preprocessing.py
qc_filtering.py
clustering.R
visualization.ipynb
```
```mermaid
flowchart LR
  A[Empty directory] -->|git init| B[Repository with .git folder]
  B -->|add files| C[Tracked project files]
```

### 2. `git status` ‚Äî Checking the lab bench

Just like checking which samples are unprocessed, they inspects their project‚Äôs state.

!!! terminal ""
    ```bash
    git status
    ```

Git reports untracked files ‚Äî nothing is committed yet.
This command becomes a habit; they run it before almost every operation.

```mermaid
flowchart LR
  WD["`Working Directory
  (modified/untracked files)`"] --> IDX[Index]
  IDX --> HEAD["`HEAD
  (committed snapshot)`"]
  style WD fill:#fffbe6,stroke:#333
  style IDX fill:#e6f7ff,stroke:#333
  style HEAD fill:#e6ffe6,stroke:#333
```


### 3. `git add` ‚Äî Staging files for the record

Like labeling tubes before freezing them, they stages files to prepare for a permanent record.

```bash
git add README.md LICENSE
git add .
```


This moves files from the working directory into the staging area, also known as the index.
Only staged files will be committed.

### 4. `git commit` ‚Äî Recording the experiment

They  capture their first snapshot.

```bash
git commit -m "Initial commit: basic pipeline structure"
```

This is their first ‚Äúfrozen sample‚Äù ‚Äî They can always revert to it later.

```mermaid
gitGraph
  commit id: "Initial commit"
```
### 5. `git branch` ‚Äî Designing new experiments

To test a new normalization method, they create a new branch ‚Äî a safe environment to experiment without contaminating their main results.

```bash
git branch normalization
git checkout normalization
```

Branches in Git are like running parallel experiments in separate tubes.
Each can evolve independently until they decide to merge the results.

```mermaid
gitGraph
  commit id: "A"
  branch normalization
  checkout normalization
  commit id: "B"
```

### 6. `git status`, `git add`, and `git commit` again

After modifying **data_preprocessing.py** to include log-normalization, they check the progress:

```bash
git status
git add data_preprocessing.py
git commit -m "Add log-normalization step for scRNA-seq data"
```


Now, their new branch contains a reproducible change.

```mermaid
gitGraph
  commit id: "A"
  branch normalization
  checkout normalization
  commit id: "Add log-normalization"
```

### 7. `git log` ‚Äî Reviewing experimental history

Every scientist keeps lab notes; Git is no different.

```bash
git log --oneline --graph --decorate
```

It shows a tidy, timestamped list of commits ‚Äî their computational ‚Äúlab notebook‚Äù.

```mermaid
gitGraph
  commit id: "Initial commit"
  commit id: "Add log-normalization"
```

### 8. `git fetch` ‚Äî Getting updates from collaborators

Their collaborator Dr. Y pushes changes to **qc_filtering.py** on the shared repository.
Before pulling them in, they fetches to see what‚Äôs changed.

```bash
git fetch origin
```


Fetching updates to their remote tracking branches (like checking a shared Google Sheet without overwriting your own copy).

```mermaid
gitGraph
  commit id: "A"
  commit id: "B" tag: "origin/main"
```

### 9. `git pull` ‚Äî Syncing the latest version

Now they merge Dr.Y's updates into their local repository.

```bash
git pull origin main
```

This performs a `fetch` + `merge`.
Their local branch is now aligned with the shared main.

```mermaid
gitGraph
  commit id: "A"
  commit id: "B"
  branch feature
  commit id: "C"
  checkout main
  merge feature
```

### 10. `git checkout` ‚Äî Switching branches

To review another experiment, Dr. X switches branches.

```bash
git checkout normalisation
```

Or to create a new one in one step:

```bash
git checkout -b clustering-tweaks
```

This is like changing which dataset or parameter set they are exploring ‚Äî safely isolated.


```mermaid
gitGraph
  commit id: "A"
  branch clustering-tweaks
  checkout clustering-tweaks
  commit id: "B"
```


### 11. `git push` ‚Äî Publishing results

When they are satisfied with their log-normalization implementation, they share it.

```bash
git push origin normalization
```

Now Dr.Y and the rest of the lab can review her branch and incorporate it into the shared project.


### 12. `git rebase` ‚Äî Keeping history tidy

After a few days, `main` has moved ahead.
Rather than `merge` and **create** messy branches, Dr.X  rebases their branch to make history look clean.

```bash
git checkout normalization
git rebase main
```


This reapplies their commits on top of the latest base ‚Äî as if they had started from the most recent code.

```mermaid
flowchart LR
  A((A)) --> B((B))
  B --> C((C))
  B --> D((D))
  D -.rebase.-> C'((C'))
  style C' fill:#fffbe6,stroke:#f90
```

```mermaid
gitGraph
  commit id: "A"
  commit id: "B"
  branch normalization
  checkout normalization
  commit id: "C"
  checkout main
  commit id: "D"
  checkout normalization
  merge main
```
### 13. `git stash` ‚Äî Pausing unfinished work

Midway through plotting, Dr. X gets a Slack message: ‚ÄúCan you quickly check that clustering bug?‚Äù
Their notebook isn‚Äôt ready to commit, but they don't want to lose their changes.

```bash
git stash
```

Their work is saved safely on the ‚Äústash stack,‚Äù and their working directory is clean again.

After debugging, they brings their changes back:

```bash
git stash pop
```

```mermaid
flowchart LR
  WD[Modified files] -->|git stash| STASH["stash@{0}"]
  STASH -->|git stash pop| WD
```


### 14. `git reset` ‚Äî Undoing a mistake

Oops ‚Äî Dr.X accidentally committed a large **matrix.mtx** test file.
They unstage it first:

```bash
git reset matrix.mtx
```

Then remove the bad commit:

```bash
git reset --soft HEAD^
```

If they want to completely delete it (be careful!):

```bash
git reset --hard HEAD^
```

Reset moves the ‚ÄúHEAD pointer‚Äù to a previous commit ‚Äî like discarding a failed experiment and reverting to known-good results.

```mermaid
gitGraph
  commit id: "Good commit"
  commit id: "Bad commit" tag: "HEAD"
  %% reset --hard HEAD^ moves HEAD back one step
```

### 15. `git merge` ‚Äî Combining branches (and resolving conflicts)

Once testing is complete, Dr.X merges her branch back into main.

```bash
git checkout main
git merge normalization
```

#### When conflicts arise ‚Äî A realistic scenario

While Dr. X was working on log-normalization in the `normalization` branch, Dr. Y was simultaneously updating the same `data_preprocessing.py` file on `main` to add a different scaling method. Now, when Dr. X tries to merge:

!!! terminal "error"

    ```bash
        Auto-merging data_preprocessing.py
        CONFLICT (content): Merge conflict in data_preprocessing.py
        Automatic merge failed; fix conflicts and then commit the result.
    ```

Git cannot automatically decide which changes to keep ‚Äî just like two scientists editing different parts of the same methods section in a manuscript.

#### Anatomy of a conflict

Opening `data_preprocessing.py`, Dr. X sees conflict markers:
```python
def normalize_counts(adata):
    """Normalize raw count data"""
<<<<<<< HEAD
    # Dr. Y's changes on main branch
    sc.pp.scale(adata, max_value=10)
    print("Applied scaling normalization")
=======
    # Dr. X's changes on normalization branch
    sc.pp.log1p(adata)
    print("Applied log-normalization")
>>>>>>> normalization
    return adata
```

The conflict markers show:
- `<<<<<<< HEAD`: Current branch (main) version
- `=======`: Separator between the two versions
- `>>>>>>> normalization`: Incoming branch version

#### Resolving the conflict

Dr. X realises both normalizations are valuable and should be applied sequentially. They manually edit the file:
```python
def normalize_counts(adata):
    """Normalize raw count data"""
    # Apply both normalization steps
    sc.pp.log1p(adata)
    sc.pp.scale(adata, max_value=10)
    print("Applied log-normalization followed by scaling")
    return adata
```

#### Completing the merge

After resolving all conflicts:

!!! terminal ""

    ```bash
        # Check which files had conflicts
        git status
        
        # Stage the resolved file
        git add data_preprocessing.py
        
        # Complete the merge with a commit
        git commit -m "Merge normalization branch: combine log and scale methods"
    ```

!!! tip "Conflict prevention tips"
    - Communicate with collaborators about which files you're editing
    - Pull frequently to stay synchronized: `git pull origin main`
    - Keep branches short-lived and focused
    - Use `git fetch` + `git diff origin/main` to preview incoming changes
```mermaid
gitGraph
  commit id: "A: Initial pipeline"
  branch normalization
  checkout normalization
  commit id: "B: Add log-norm"
  checkout main
  commit id: "C: Add scaling"
  merge normalization tag: "Resolved: Both methods"
```

#### Advanced: Using merge tools

For complex conflicts, Dr. X can use visual merge tools:
```bash
# Configure a merge tool (e.g., VS Code, Meld, or vimdiff)
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'

# Launch the merge tool
git mergetool
```

This opens a side-by-side comparison, making it easier to see differences and choose the correct resolution.
```mermaid
flowchart TB
  A[Merge conflict detected] --> B{Conflict complexity?}
  B -->|Simple| C[Manual editing]
  B -->|Complex| D[Visual merge tool]
  C --> E[git add file]
  D --> E
  E --> F[git commit]
  F --> G[Merge complete ‚úì]
  style A fill:#ffe6e6,stroke:#f00
  style G fill:#e6ffe6,stroke:#0f0
```