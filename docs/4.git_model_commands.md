# <h1 align="center">4. Git Concepts, Data Model and Commands ðŸŽ¨</h1>

<p align="center">
    <img src="../images/gitcommand_episode_logo.png" alt="drawing" width="250">
</p>



<h2 align="center">Version Control for Cell Clusters â€” A Git Journey in the Lab</h2>

Dr. X is a computational biologist working on a new single-cell RNA sequencing (scRNA-seq) pipeline.
Like most data scientists, their workflow involves constant tweaking: preprocessing, quality control, normalization, clustering, and visualization.

They are tired of lost scripts, mysterious file versions like `clustering_final_FINAL.R`, and overwritten notebooks.

So, they decided to version-control their pipeline properly using **Git**

### 1. `git init` - Starting a new experiment 

They begin their project as they would a new experiment â€” setting up a clean workspace.

!!! terminal ""

    ```bash
    mkdir CellCulsterFlow
    cd CellClusterFlow
    ```
    
    ```bash
    git init
    ```
This initialises an empty Git repository, like labeling an empty freezer box before adding samples.
Every change from here on will be tracked.

They create few essential files 

```bash
README.md
LICENSE
data_preprocessing.py
qc_filtering.py
clustering.R
visualization.ipynb
```
```mermaid
flowchart LR
  A[Empty directory] -->|git init| B[Repository with .git folder]
  B -->|add files| C[Tracked project files]
```

### 2. `git status` â€” Checking the lab bench

Just like checking which samples are unprocessed, they inspects their projectâ€™s state.

!!! terminal ""
    ```bash
    git status
    ```

Git reports untracked files â€” nothing is committed yet.
This command becomes a habit; they run it before almost every operation.

```mermaid
flowchart LR
  WD["`Working Directory
  (modified/untracked files)`"] --> IDX[Index]
  IDX --> HEAD["`HEAD
  (committed snapshot)`"]
  style WD fill:#fffbe6,stroke:#333
  style IDX fill:#e6f7ff,stroke:#333
  style HEAD fill:#e6ffe6,stroke:#333
```


### 3. `git add` â€” Staging files for the record

Like labeling tubes before freezing them, they stages files to prepare for a permanent record.

```bash
git add README.md LICENSE
git add .
```


This moves files from the working directory into the staging area, also known as the index.
Only staged files will be committed.

### 4. `git commit` â€” Recording the experiment

They  capture their first snapshot.

```bash
git commit -m "Initial commit: basic pipeline structure"
```

This is their first â€œfrozen sampleâ€ â€” They can always revert to it later.

```mermaid
gitGraph
  commit id: "Initial commit"
```
### 5. `git branch` â€” Designing new experiments

To test a new normalization method, they create a new branch â€” a safe environment to experiment without contaminating their main results.

```bash
git branch normalization
git checkout normalization
```

Branches in Git are like running parallel experiments in separate tubes.
Each can evolve independently until they decide to merge the results.

```mermaid
gitGraph
  commit id: "A"
  branch normalization
  checkout normalization
  commit id: "B"
```

### 6. `git status`, `git add`, and `git commit` again

After modifying **data_preprocessing.py** to include log-normalization, they check the progress:

```bash
git status
git add data_preprocessing.py
git commit -m "Add log-normalization step for scRNA-seq data"
```


Now, their new branch contains a reproducible change.

```mermaid
gitGraph
  commit id: "A"
  branch normalization
  checkout normalization
  commit id: "Add log-normalization"
```

### 7. `git log` â€” Reviewing experimental history

Every scientist keeps lab notes; Git is no different.

```bash
git log --oneline --graph --decorate
```

It shows a tidy, timestamped list of commits â€” their computational â€œlab notebookâ€.

```mermaid
gitGraph
  commit id: "Initial commit"
  commit id: "Add log-normalization"
```

### 8. `git fetch` â€” Getting updates from collaborators

Their collaborator Dr. Y pushes changes to **qc_filtering.py** on the shared repository.
Before pulling them in, they fetches to see whatâ€™s changed.

```bash
git fetch origin
```


Fetching updates to their remote tracking branches (like checking a shared Google Sheet without overwriting your own copy).

```mermaid
gitGraph
  commit id: "A"
  commit id: "B" tag: "origin/main"
```

### 9. `git pull` â€” Syncing the latest version

Now they merge Dr.Y's updates into their local repository.

```bash
git pull origin main
```

This performs a `fetch` + `merge`.
Their local branch is now aligned with the shared main.

```mermaid
gitGraph
  commit id: "A"
  commit id: "B"
  branch feature
  commit id: "C"
  checkout main
  merge feature
```

### 10. `git checkout` â€” Switching branches

To review another experiment, Dr. X switches branches.

```bash
git checkout normalisation
```

Or to create a new one in one step:

```bash
git checkout -b clustering-tweaks
```

This is like changing which dataset or parameter set they are exploring â€” safely isolated.


```mermaid
gitGraph
  commit id: "A"
  branch clustering-tweaks
  checkout clustering-tweaks
  commit id: "B"
```


### 11. `git push` â€” Publishing results

When they are satisfied with their log-normalization implementation, they share it.

```bash
git push origin normalization
```

Now Dr.Y and the rest of the lab can review her branch and incorporate it into the shared project.


### 12. `git rebase` â€” Keeping history tidy

After a few days, `main` has moved ahead.
Rather than `merge` and **create** messy branches, Dr.X  rebases their branch to make history look clean.

```bash
git checkout normalization
git rebase main
```


This reapplies their commits on top of the latest base â€” as if they had started from the most recent code.

```mermaid
flowchart LR
  A((A)) --> B((B))
  B --> C((C))
  B --> D((D))
  D -.rebase.-> C'((C'))
  style C' fill:#fffbe6,stroke:#f90
```

```mermaid
gitGraph
  commit id: "A"
  commit id: "B"
  branch normalization
  checkout normalization
  commit id: "C"
  checkout main
  commit id: "D"
  checkout normalization
  merge main
```
